{
  "version": 3,
  "sources": ["../../assemblyai/dist/browser.mjs"],
  "sourcesContent": ["const DEFAULT_FETCH_INIT = {\n    cache: \"no-store\",\n};\n\nconst buildUserAgent = (userAgent) => defaultUserAgentString +\n    (userAgent === false\n        ? \"\"\n        : \" AssemblyAI/1.0 (\" +\n            Object.entries({ ...defaultUserAgent, ...userAgent })\n                .map(([key, item]) => item ? `${key}=${item.name}/${item.version}` : \"\")\n                .join(\" \") +\n            \")\");\nlet defaultUserAgentString = \"\";\nif (typeof navigator !== \"undefined\" && navigator.userAgent) {\n    defaultUserAgentString += navigator.userAgent;\n}\nconst defaultUserAgent = {\n    sdk: { name: \"JavaScript\", version: \"4.8.0\" },\n};\nif (typeof process !== \"undefined\") {\n    if (process.versions.node && defaultUserAgentString.indexOf(\"Node\") === -1) {\n        defaultUserAgent.runtime_env = {\n            name: \"Node\",\n            version: process.versions.node,\n        };\n    }\n    if (process.versions.bun && defaultUserAgentString.indexOf(\"Bun\") === -1) {\n        defaultUserAgent.runtime_env = {\n            name: \"Bun\",\n            version: process.versions.bun,\n        };\n    }\n}\nif (typeof Deno !== \"undefined\") {\n    if (process.versions.bun && defaultUserAgentString.indexOf(\"Deno\") === -1) {\n        defaultUserAgent.runtime_env = { name: \"Deno\", version: Deno.version.deno };\n    }\n}\n\n/**\n * Base class for services that communicate with the API.\n */\nclass BaseService {\n    /**\n     * Create a new service.\n     * @param params - The parameters to use for the service.\n     */\n    constructor(params) {\n        this.params = params;\n        if (params.userAgent === false) {\n            this.userAgent = undefined;\n        }\n        else {\n            this.userAgent = buildUserAgent(params.userAgent || {});\n        }\n    }\n    async fetch(input, init) {\n        init = { ...DEFAULT_FETCH_INIT, ...init };\n        let headers = {\n            Authorization: this.params.apiKey,\n            \"Content-Type\": \"application/json\",\n        };\n        if (DEFAULT_FETCH_INIT?.headers)\n            headers = { ...headers, ...DEFAULT_FETCH_INIT.headers };\n        if (init?.headers)\n            headers = { ...headers, ...init.headers };\n        if (this.userAgent) {\n            headers[\"User-Agent\"] = this.userAgent;\n            {\n                // chromium browsers have a bug where the user agent can't be modified\n                if (typeof window !== \"undefined\" && \"chrome\" in window) {\n                    headers[\"AssemblyAI-Agent\"] =\n                        this.userAgent;\n                }\n            }\n        }\n        init.headers = headers;\n        if (!input.startsWith(\"http\"))\n            input = this.params.baseUrl + input;\n        const response = await fetch(input, init);\n        if (response.status >= 400) {\n            let json;\n            const text = await response.text();\n            if (text) {\n                try {\n                    json = JSON.parse(text);\n                }\n                catch {\n                    /* empty */\n                }\n                if (json?.error)\n                    throw new Error(json.error);\n                throw new Error(text);\n            }\n            throw new Error(`HTTP Error: ${response.status} ${response.statusText}`);\n        }\n        return response;\n    }\n    async fetchJson(input, init) {\n        const response = await this.fetch(input, init);\n        return response.json();\n    }\n}\n\nclass LemurService extends BaseService {\n    summary(params) {\n        return this.fetchJson(\"/lemur/v3/generate/summary\", {\n            method: \"POST\",\n            body: JSON.stringify(params),\n        });\n    }\n    questionAnswer(params) {\n        return this.fetchJson(\"/lemur/v3/generate/question-answer\", {\n            method: \"POST\",\n            body: JSON.stringify(params),\n        });\n    }\n    actionItems(params) {\n        return this.fetchJson(\"/lemur/v3/generate/action-items\", {\n            method: \"POST\",\n            body: JSON.stringify(params),\n        });\n    }\n    task(params) {\n        return this.fetchJson(\"/lemur/v3/generate/task\", {\n            method: \"POST\",\n            body: JSON.stringify(params),\n        });\n    }\n    getResponse(id) {\n        return this.fetchJson(`/lemur/v3/${id}`);\n    }\n    /**\n     * Delete the data for a previously submitted LeMUR request.\n     * @param id - ID of the LeMUR request\n     */\n    purgeRequestData(id) {\n        return this.fetchJson(`/lemur/v3/${id}`, {\n            method: \"DELETE\",\n        });\n    }\n}\n\nconst { WritableStream } = typeof window !== \"undefined\"\n    ? window\n    : typeof global !== \"undefined\"\n        ? global\n        : globalThis;\n\nconst PolyfillWebSocket = WebSocket ?? global?.WebSocket ?? window?.WebSocket ?? self?.WebSocket;\nconst factory = (url, params) => {\n    if (params) {\n        return new PolyfillWebSocket(url, params);\n    }\n    return new PolyfillWebSocket(url);\n};\n\nconst RealtimeErrorType = {\n    BadSampleRate: 4000,\n    AuthFailed: 4001,\n    /**\n     * @deprecated Use InsufficientFunds or FreeTierUser instead\n     */\n    InsufficientFundsOrFreeAccount: 4002,\n    InsufficientFunds: 4002,\n    FreeTierUser: 4003,\n    NonexistentSessionId: 4004,\n    SessionExpired: 4008,\n    ClosedSession: 4010,\n    RateLimited: 4029,\n    UniqueSessionViolation: 4030,\n    SessionTimeout: 4031,\n    AudioTooShort: 4032,\n    AudioTooLong: 4033,\n    AudioTooSmallToTranscode: 4034,\n    /**\n     * @deprecated Don't use\n     */\n    BadJson: 4100,\n    BadSchema: 4101,\n    TooManyStreams: 4102,\n    Reconnected: 4103,\n    /**\n     * @deprecated Don't use\n     */\n    ReconnectAttemptsExhausted: 1013,\n    WordBoostParameterParsingFailed: 4104,\n};\nconst RealtimeErrorMessages = {\n    [RealtimeErrorType.BadSampleRate]: \"Sample rate must be a positive integer\",\n    [RealtimeErrorType.AuthFailed]: \"Not Authorized\",\n    [RealtimeErrorType.InsufficientFunds]: \"Insufficient funds\",\n    [RealtimeErrorType.FreeTierUser]: \"This feature is paid-only and requires you to add a credit card. Please visit https://app.assemblyai.com/ to add a credit card to your account.\",\n    [RealtimeErrorType.NonexistentSessionId]: \"Session ID does not exist\",\n    [RealtimeErrorType.SessionExpired]: \"Session has expired\",\n    [RealtimeErrorType.ClosedSession]: \"Session is closed\",\n    [RealtimeErrorType.RateLimited]: \"Rate limited\",\n    [RealtimeErrorType.UniqueSessionViolation]: \"Unique session violation\",\n    [RealtimeErrorType.SessionTimeout]: \"Session Timeout\",\n    [RealtimeErrorType.AudioTooShort]: \"Audio too short\",\n    [RealtimeErrorType.AudioTooLong]: \"Audio too long\",\n    [RealtimeErrorType.AudioTooSmallToTranscode]: \"Audio too small to transcode\",\n    [RealtimeErrorType.BadJson]: \"Bad JSON\",\n    [RealtimeErrorType.BadSchema]: \"Bad schema\",\n    [RealtimeErrorType.TooManyStreams]: \"Too many streams\",\n    [RealtimeErrorType.Reconnected]: \"This session has been reconnected. This WebSocket is no longer valid.\",\n    [RealtimeErrorType.ReconnectAttemptsExhausted]: \"Reconnect attempts exhausted\",\n    [RealtimeErrorType.WordBoostParameterParsingFailed]: \"Could not parse word boost parameter\",\n};\nclass RealtimeError extends Error {\n}\n\nconst defaultRealtimeUrl = \"wss://api.assemblyai.com/v2/realtime/ws\";\nconst forceEndOfUtteranceMessage = `{\"force_end_utterance\":true}`;\nconst terminateSessionMessage = `{\"terminate_session\":true}`;\n/**\n * RealtimeTranscriber connects to the Streaming Speech-to-Text API and lets you transcribe audio in real-time.\n */\nclass RealtimeTranscriber {\n    /**\n     * Create a new RealtimeTranscriber.\n     * @param params - Parameters to configure the RealtimeTranscriber\n     */\n    constructor(params) {\n        this.listeners = {};\n        this.realtimeUrl = params.realtimeUrl ?? defaultRealtimeUrl;\n        this.sampleRate = params.sampleRate ?? 16_000;\n        this.wordBoost = params.wordBoost;\n        this.encoding = params.encoding;\n        this.endUtteranceSilenceThreshold = params.endUtteranceSilenceThreshold;\n        this.disablePartialTranscripts = params.disablePartialTranscripts;\n        if (\"token\" in params && params.token)\n            this.token = params.token;\n        if (\"apiKey\" in params && params.apiKey)\n            this.apiKey = params.apiKey;\n        if (!(this.token || this.apiKey)) {\n            throw new Error(\"API key or temporary token is required.\");\n        }\n    }\n    connectionUrl() {\n        const url = new URL(this.realtimeUrl);\n        if (url.protocol !== \"wss:\") {\n            throw new Error(\"Invalid protocol, must be wss\");\n        }\n        const searchParams = new URLSearchParams();\n        if (this.token) {\n            searchParams.set(\"token\", this.token);\n        }\n        searchParams.set(\"sample_rate\", this.sampleRate.toString());\n        if (this.wordBoost && this.wordBoost.length > 0) {\n            searchParams.set(\"word_boost\", JSON.stringify(this.wordBoost));\n        }\n        if (this.encoding) {\n            searchParams.set(\"encoding\", this.encoding);\n        }\n        searchParams.set(\"enable_extra_session_information\", \"true\");\n        if (this.disablePartialTranscripts) {\n            searchParams.set(\"disable_partial_transcripts\", this.disablePartialTranscripts.toString());\n        }\n        url.search = searchParams.toString();\n        return url;\n    }\n    /**\n     * Add a listener for an event.\n     * @param event - The event to listen for.\n     * @param listener - The function to call when the event is emitted.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    on(event, listener) {\n        this.listeners[event] = listener;\n    }\n    /**\n     * Connect to the server and begin a new session.\n     * @returns A promise that resolves when the connection is established and the session begins.\n     */\n    connect() {\n        return new Promise((resolve) => {\n            if (this.socket) {\n                throw new Error(\"Already connected\");\n            }\n            const url = this.connectionUrl();\n            if (this.token) {\n                this.socket = factory(url.toString());\n            }\n            else {\n                {\n                    console.warn(`API key authentication is not supported for the RealtimeTranscriber in browser environment. Use temporary token authentication instead.\nLearn more at https://github.com/AssemblyAI/assemblyai-node-sdk/blob/main/docs/compat.md#browser-compatibility.`);\n                }\n                this.socket = factory(url.toString(), {\n                    headers: { Authorization: this.apiKey },\n                });\n            }\n            this.socket.binaryType = \"arraybuffer\";\n            this.socket.onopen = () => {\n                if (this.endUtteranceSilenceThreshold === undefined ||\n                    this.endUtteranceSilenceThreshold === null) {\n                    return;\n                }\n                this.configureEndUtteranceSilenceThreshold(this.endUtteranceSilenceThreshold);\n            };\n            this.socket.onclose = ({ code, reason }) => {\n                if (!reason) {\n                    if (code in RealtimeErrorMessages) {\n                        reason = RealtimeErrorMessages[code];\n                    }\n                }\n                this.listeners.close?.(code, reason);\n            };\n            this.socket.onerror = (event) => {\n                if (event.error)\n                    this.listeners.error?.(event.error);\n                else\n                    this.listeners.error?.(new Error(event.message));\n            };\n            this.socket.onmessage = ({ data }) => {\n                const message = JSON.parse(data.toString());\n                if (\"error\" in message) {\n                    this.listeners.error?.(new RealtimeError(message.error));\n                    return;\n                }\n                switch (message.message_type) {\n                    case \"SessionBegins\": {\n                        const openObject = {\n                            sessionId: message.session_id,\n                            expiresAt: new Date(message.expires_at),\n                        };\n                        resolve(openObject);\n                        this.listeners.open?.(openObject);\n                        break;\n                    }\n                    case \"PartialTranscript\": {\n                        // message.created is actually a string when coming from the socket\n                        message.created = new Date(message.created);\n                        this.listeners.transcript?.(message);\n                        this.listeners[\"transcript.partial\"]?.(message);\n                        break;\n                    }\n                    case \"FinalTranscript\": {\n                        // message.created is actually a string when coming from the socket\n                        message.created = new Date(message.created);\n                        this.listeners.transcript?.(message);\n                        this.listeners[\"transcript.final\"]?.(message);\n                        break;\n                    }\n                    case \"SessionInformation\": {\n                        this.listeners.session_information?.(message);\n                        break;\n                    }\n                    case \"SessionTerminated\": {\n                        this.sessionTerminatedResolve?.();\n                        break;\n                    }\n                }\n            };\n        });\n    }\n    /**\n     * Send audio data to the server.\n     * @param audio - The audio data to send to the server.\n     */\n    sendAudio(audio) {\n        this.send(audio);\n    }\n    /**\n     * Create a writable stream that can be used to send audio data to the server.\n     * @returns A writable stream that can be used to send audio data to the server.\n     */\n    stream() {\n        return new WritableStream({\n            write: (chunk) => {\n                this.sendAudio(chunk);\n            },\n        });\n    }\n    /**\n     * Manually end an utterance\n     */\n    forceEndUtterance() {\n        this.send(forceEndOfUtteranceMessage);\n    }\n    /**\n     * Configure the threshold for how long to wait before ending an utterance. Default is 700ms.\n     * @param threshold - The duration of the end utterance silence threshold in milliseconds.\n     * This value must be an integer between 0 and 20_000.\n     */\n    configureEndUtteranceSilenceThreshold(threshold) {\n        this.send(`{\"end_utterance_silence_threshold\":${threshold}}`);\n    }\n    send(data) {\n        if (!this.socket || this.socket.readyState !== this.socket.OPEN) {\n            throw new Error(\"Socket is not open for communication\");\n        }\n        this.socket.send(data);\n    }\n    /**\n     * Close the connection to the server.\n     * @param waitForSessionTermination - If true, the method will wait for the session to be terminated before closing the connection.\n     * While waiting for the session to be terminated, you will receive the final transcript and session information.\n     */\n    async close(waitForSessionTermination = true) {\n        if (this.socket) {\n            if (this.socket.readyState === this.socket.OPEN) {\n                if (waitForSessionTermination) {\n                    const sessionTerminatedPromise = new Promise((resolve) => {\n                        this.sessionTerminatedResolve = resolve;\n                    });\n                    this.socket.send(terminateSessionMessage);\n                    await sessionTerminatedPromise;\n                }\n                else {\n                    this.socket.send(terminateSessionMessage);\n                }\n            }\n            if (this.socket?.removeAllListeners)\n                this.socket.removeAllListeners();\n            this.socket.close();\n        }\n        this.listeners = {};\n        this.socket = undefined;\n    }\n}\n/**\n * @deprecated Use RealtimeTranscriber instead\n */\nclass RealtimeService extends RealtimeTranscriber {\n}\n\nclass RealtimeTranscriberFactory extends BaseService {\n    constructor(params) {\n        super(params);\n        this.rtFactoryParams = params;\n    }\n    /**\n     * @deprecated Use transcriber(...) instead\n     */\n    createService(params) {\n        return this.transcriber(params);\n    }\n    transcriber(params) {\n        const serviceParams = { ...params };\n        if (!serviceParams.token && !serviceParams.apiKey) {\n            serviceParams.apiKey = this.rtFactoryParams.apiKey;\n        }\n        return new RealtimeTranscriber(serviceParams);\n    }\n    async createTemporaryToken(params) {\n        const data = await this.fetchJson(\"/v2/realtime/token\", {\n            method: \"POST\",\n            body: JSON.stringify(params),\n        });\n        return data.token;\n    }\n}\n/**\n * @deprecated Use RealtimeTranscriberFactory instead\n */\nclass RealtimeServiceFactory extends RealtimeTranscriberFactory {\n}\n\nfunction getPath(path) {\n    if (path.startsWith(\"http\"))\n        return null;\n    if (path.startsWith(\"https\"))\n        return null;\n    if (path.startsWith(\"data:\"))\n        return null;\n    if (path.startsWith(\"file://\"))\n        return path.substring(7);\n    if (path.startsWith(\"file:\"))\n        return path.substring(5);\n    return path;\n}\n\nclass TranscriptService extends BaseService {\n    constructor(params, files) {\n        super(params);\n        this.files = files;\n    }\n    /**\n     * Transcribe an audio file. This will create a transcript and wait until the transcript status is \"completed\" or \"error\".\n     * @param params - The parameters to transcribe an audio file.\n     * @param options - The options to transcribe an audio file.\n     * @returns A promise that resolves to the transcript. The transcript status is \"completed\" or \"error\".\n     */\n    async transcribe(params, options) {\n        const transcript = await this.submit(params);\n        return await this.waitUntilReady(transcript.id, options);\n    }\n    /**\n     * Submits a transcription job for an audio file. This will not wait until the transcript status is \"completed\" or \"error\".\n     * @param params - The parameters to start the transcription of an audio file.\n     * @returns A promise that resolves to the queued transcript.\n     */\n    async submit(params) {\n        let audioUrl;\n        let transcriptParams = undefined;\n        if (\"audio\" in params) {\n            const { audio, ...audioTranscriptParams } = params;\n            if (typeof audio === \"string\") {\n                const path = getPath(audio);\n                if (path !== null) {\n                    // audio is local path, upload local file\n                    audioUrl = await this.files.upload(path);\n                }\n                else {\n                    if (audio.startsWith(\"data:\")) {\n                        audioUrl = await this.files.upload(audio);\n                    }\n                    else {\n                        // audio is not a local path, and not a data-URI, assume it's a normal URL\n                        audioUrl = audio;\n                    }\n                }\n            }\n            else {\n                // audio is of uploadable type\n                audioUrl = await this.files.upload(audio);\n            }\n            transcriptParams = { ...audioTranscriptParams, audio_url: audioUrl };\n        }\n        else {\n            transcriptParams = params;\n        }\n        const data = await this.fetchJson(\"/v2/transcript\", {\n            method: \"POST\",\n            body: JSON.stringify(transcriptParams),\n        });\n        return data;\n    }\n    /**\n     * Create a transcript.\n     * @param params - The parameters to create a transcript.\n     * @param options - The options used for creating the new transcript.\n     * @returns A promise that resolves to the transcript.\n     * @deprecated Use `transcribe` instead to transcribe a audio file that includes polling, or `submit` to transcribe a audio file without polling.\n     */\n    async create(params, options) {\n        const path = getPath(params.audio_url);\n        if (path !== null) {\n            const uploadUrl = await this.files.upload(path);\n            params.audio_url = uploadUrl;\n        }\n        const data = await this.fetchJson(\"/v2/transcript\", {\n            method: \"POST\",\n            body: JSON.stringify(params),\n        });\n        if (options?.poll ?? true) {\n            return await this.waitUntilReady(data.id, options);\n        }\n        return data;\n    }\n    /**\n     * Wait until the transcript ready, either the status is \"completed\" or \"error\".\n     * @param transcriptId - The ID of the transcript.\n     * @param options - The options to wait until the transcript is ready.\n     * @returns A promise that resolves to the transcript. The transcript status is \"completed\" or \"error\".\n     */\n    async waitUntilReady(transcriptId, options) {\n        const pollingInterval = options?.pollingInterval ?? 3_000;\n        const pollingTimeout = options?.pollingTimeout ?? -1;\n        const startTime = Date.now();\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            const transcript = await this.get(transcriptId);\n            if (transcript.status === \"completed\" || transcript.status === \"error\") {\n                return transcript;\n            }\n            else if (pollingTimeout > 0 &&\n                Date.now() - startTime > pollingTimeout) {\n                throw new Error(\"Polling timeout\");\n            }\n            else {\n                await new Promise((resolve) => setTimeout(resolve, pollingInterval));\n            }\n        }\n    }\n    /**\n     * Retrieve a transcript.\n     * @param id - The identifier of the transcript.\n     * @returns A promise that resolves to the transcript.\n     */\n    get(id) {\n        return this.fetchJson(`/v2/transcript/${id}`);\n    }\n    /**\n     * Retrieves a page of transcript listings.\n     * @param params - The parameters to filter the transcript list by, or the URL to retrieve the transcript list from.\n     */\n    async list(params) {\n        let url = \"/v2/transcript\";\n        if (typeof params === \"string\") {\n            url = params;\n        }\n        else if (params) {\n            url = `${url}?${new URLSearchParams(Object.keys(params).map((key) => [\n                key,\n                params[key]?.toString() || \"\",\n            ]))}`;\n        }\n        const data = await this.fetchJson(url);\n        for (const transcriptListItem of data.transcripts) {\n            transcriptListItem.created = new Date(transcriptListItem.created);\n            if (transcriptListItem.completed) {\n                transcriptListItem.completed = new Date(transcriptListItem.completed);\n            }\n        }\n        return data;\n    }\n    /**\n     * Delete a transcript\n     * @param id - The identifier of the transcript.\n     * @returns A promise that resolves to the transcript.\n     */\n    delete(id) {\n        return this.fetchJson(`/v2/transcript/${id}`, { method: \"DELETE\" });\n    }\n    /**\n     * Search through the transcript for a specific set of keywords.\n     * You can search for individual words, numbers, or phrases containing up to five words or numbers.\n     * @param id - The identifier of the transcript.\n     * @param words - Keywords to search for.\n     * @returns A promise that resolves to the sentences.\n     */\n    wordSearch(id, words) {\n        const params = new URLSearchParams({ words: words.join(\",\") });\n        return this.fetchJson(`/v2/transcript/${id}/word-search?${params.toString()}`);\n    }\n    /**\n     * Retrieve all sentences of a transcript.\n     * @param id - The identifier of the transcript.\n     * @returns A promise that resolves to the sentences.\n     */\n    sentences(id) {\n        return this.fetchJson(`/v2/transcript/${id}/sentences`);\n    }\n    /**\n     * Retrieve all paragraphs of a transcript.\n     * @param id - The identifier of the transcript.\n     * @returns A promise that resolves to the paragraphs.\n     */\n    paragraphs(id) {\n        return this.fetchJson(`/v2/transcript/${id}/paragraphs`);\n    }\n    /**\n     * Retrieve subtitles of a transcript.\n     * @param id - The identifier of the transcript.\n     * @param format - The format of the subtitles.\n     * @param chars_per_caption - The maximum number of characters per caption.\n     * @returns A promise that resolves to the subtitles text.\n     */\n    async subtitles(id, format = \"srt\", chars_per_caption) {\n        let url = `/v2/transcript/${id}/${format}`;\n        if (chars_per_caption) {\n            const params = new URLSearchParams();\n            params.set(\"chars_per_caption\", chars_per_caption.toString());\n            url += `?${params.toString()}`;\n        }\n        const response = await this.fetch(url);\n        return await response.text();\n    }\n    /**\n     * Retrieve the redacted audio URL of a transcript.\n     * @param id - The identifier of the transcript.\n     * @returns A promise that resolves to the details of the redacted audio.\n     * @deprecated Use `redactedAudio` instead.\n     */\n    redactions(id) {\n        return this.redactedAudio(id);\n    }\n    /**\n     * Retrieve the redacted audio URL of a transcript.\n     * @param id - The identifier of the transcript.\n     * @returns A promise that resolves to the details of the redacted audio.\n     */\n    redactedAudio(id) {\n        return this.fetchJson(`/v2/transcript/${id}/redacted-audio`);\n    }\n    /**\n     * Retrieve the redacted audio file of a transcript.\n     * @param id - The identifier of the transcript.\n     * @returns A promise that resolves to the fetch HTTP response of the redacted audio file.\n     */\n    async redactedAudioFile(id) {\n        const { redacted_audio_url, status } = await this.redactedAudio(id);\n        if (status !== \"redacted_audio_ready\") {\n            throw new Error(`Redacted audio status is ${status}`);\n        }\n        const response = await fetch(redacted_audio_url);\n        if (!response.ok) {\n            throw new Error(`Failed to fetch redacted audio: ${response.statusText}`);\n        }\n        return {\n            arrayBuffer: response.arrayBuffer.bind(response),\n            blob: response.blob.bind(response),\n            body: response.body,\n            bodyUsed: response.bodyUsed,\n        };\n    }\n}\n\nconst readFile = async function (\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\npath) {\n    throw new Error(\"Interacting with the file system is not supported in this environment.\");\n};\n\nclass FileService extends BaseService {\n    /**\n     * Upload a local file to AssemblyAI.\n     * @param input - The local file path to upload, or a stream or buffer of the file to upload.\n     * @returns A promise that resolves to the uploaded file URL.\n     */\n    async upload(input) {\n        let fileData;\n        if (typeof input === \"string\") {\n            if (input.startsWith(\"data:\")) {\n                fileData = dataUrlToBlob(input);\n            }\n            else {\n                fileData = await readFile();\n            }\n        }\n        else\n            fileData = input;\n        const data = await this.fetchJson(\"/v2/upload\", {\n            method: \"POST\",\n            body: fileData,\n            headers: {\n                \"Content-Type\": \"application/octet-stream\",\n            },\n            duplex: \"half\",\n        });\n        return data.upload_url;\n    }\n}\nfunction dataUrlToBlob(dataUrl) {\n    const arr = dataUrl.split(\",\");\n    const mime = arr[0].match(/:(.*?);/)[1];\n    const bstr = atob(arr[1]);\n    let n = bstr.length;\n    const u8arr = new Uint8Array(n);\n    while (n--) {\n        u8arr[n] = bstr.charCodeAt(n);\n    }\n    return new Blob([u8arr], { type: mime });\n}\n\nconst defaultBaseUrl = \"https://api.assemblyai.com\";\nclass AssemblyAI {\n    /**\n     * Create a new AssemblyAI client.\n     * @param params - The parameters for the service, including the API key and base URL, if any.\n     */\n    constructor(params) {\n        params.baseUrl = params.baseUrl || defaultBaseUrl;\n        if (params.baseUrl && params.baseUrl.endsWith(\"/\")) {\n            params.baseUrl = params.baseUrl.slice(0, -1);\n        }\n        this.files = new FileService(params);\n        this.transcripts = new TranscriptService(params, this.files);\n        this.lemur = new LemurService(params);\n        this.realtime = new RealtimeTranscriberFactory(params);\n    }\n}\n\nexport { AssemblyAI, FileService, LemurService, RealtimeService, RealtimeServiceFactory, RealtimeTranscriber, RealtimeTranscriberFactory, TranscriptService };\n"],
  "mappings": "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",
  "names": []
}
